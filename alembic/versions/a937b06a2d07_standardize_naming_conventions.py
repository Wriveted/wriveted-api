"""Standardize naming conventions

Revision ID: a937b06a2d07
Revises: 0e96090c57f5
Create Date: 2026-01-09 11:13:23.636592

"""

import sqlalchemy as sa
from alembic_utils.pg_extension import PGExtension
from alembic_utils.pg_function import PGFunction
from sqlalchemy import text as sql_text
from sqlalchemy.dialects import postgresql

from alembic import op

# revision identifiers, used by Alembic.
revision = "a937b06a2d07"
down_revision = "0e96090c57f5"
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(op.f("ck_booklist_order"), "book_list_works", type_="unique")
    op.drop_index(op.f("index_booklist_ordered"), table_name="book_list_works")
    op.create_index(
        "ix_booklistworkassociations_booklist_id_order_id",
        "book_list_works",
        ["booklist_id", "order_id"],
        unique=False,
    )
    op.create_unique_constraint(
        "uq_booklistworkassociations_booklist_id_order_id",
        "book_list_works",
        ["booklist_id", "order_id"],
        deferrable=True,
    )
    op.drop_index(op.f("idx_chat_themes_created_by"), table_name="chat_themes")
    op.drop_index(op.f("idx_chat_themes_is_active"), table_name="chat_themes")
    op.drop_index(op.f("idx_chat_themes_is_default"), table_name="chat_themes")
    op.drop_index(op.f("idx_chat_themes_school_id"), table_name="chat_themes")
    op.create_index(
        op.f("ix_chat_themes_is_active"), "chat_themes", ["is_active"], unique=False
    )
    op.create_index(
        op.f("ix_chat_themes_school_id"), "chat_themes", ["school_id"], unique=False
    )
    op.drop_constraint(
        op.f("unique_class_name_per_school"), "class_groups", type_="unique"
    )
    op.create_unique_constraint(
        "uq_class_groups_name_school_id", "class_groups", ["name", "school_id"]
    )
    op.drop_index(
        op.f("idx_cms_content_search_document"),
        table_name="cms_content",
        postgresql_using="gin",
    )
    op.create_index(
        "ix_cms_content_search_document",
        "cms_content",
        ["search_document"],
        unique=False,
        postgresql_using="gin",
    )
    op.alter_column(
        "cms_content_variants",
        "performance_data",
        existing_type=postgresql.JSONB(astext_type=sa.Text()),
        type_=sa.JSON(),
        existing_nullable=False,
        existing_server_default=sa.text("'{}'::json"),
    )
    op.drop_index(
        op.f("ix_cms_content_variants_content_id"), table_name="cms_content_variants"
    )
    op.drop_index(
        op.f("ix_cms_content_variants_is_active"), table_name="cms_content_variants"
    )
    op.create_unique_constraint(
        "uq_content_variant_key", "cms_content_variants", ["content_id", "variant_key"]
    )
    op.drop_column("cms_content_variants", "updated_at")
    op.drop_index(
        op.f("idx_collection_item_activity_log_timestamp_reader_id"),
        table_name="collection_item_activity_log",
    )
    op.create_index(
        "ix_collectionitemactivitys_timestamp_reader_id",
        "collection_item_activity_log",
        ["timestamp", "reader_id"],
        unique=False,
    )
    op.drop_constraint(
        op.f("unique_editions_per_collection"), "collection_items", type_="unique"
    )
    op.create_unique_constraint(
        "uq_collection_items_collection_id_edition_isbn",
        "collection_items",
        ["collection_id", "edition_isbn"],
    )
    op.drop_index(
        op.f("ix_conversation_analytics_flow_id"), table_name="conversation_analytics"
    )
    op.create_unique_constraint(
        "uq_analytics_flow_node_date",
        "conversation_analytics",
        ["flow_id", "node_id", "date"],
    )
    op.drop_column("conversation_analytics", "updated_at")
    op.alter_column(
        "event_outbox",
        "payload",
        existing_type=postgresql.JSON(astext_type=sa.Text()),
        type_=postgresql.JSONB(astext_type=sa.Text()),
        existing_nullable=False,
    )
    op.alter_column(
        "event_outbox",
        "headers",
        existing_type=postgresql.JSON(astext_type=sa.Text()),
        type_=postgresql.JSONB(astext_type=sa.Text()),
        existing_nullable=True,
    )
    op.alter_column(
        "event_outbox",
        "error_details",
        existing_type=postgresql.JSON(astext_type=sa.Text()),
        type_=postgresql.JSONB(astext_type=sa.Text()),
        existing_nullable=True,
    )
    op.create_index(
        op.f("ix_event_outbox_correlation_id"),
        "event_outbox",
        ["correlation_id"],
        unique=False,
    )
    op.create_index(
        op.f("ix_event_outbox_routing_key"),
        "event_outbox",
        ["routing_key"],
        unique=False,
    )

    # Handle flow_nodes index changes FIRST (before creating FKs that depend on them)
    op.drop_index(op.f("idx_flow_nodes_execution_context"), table_name="flow_nodes")
    op.drop_index(op.f("ix_flow_nodes_flow_id"), table_name="flow_nodes")
    op.drop_index(op.f("ix_flow_nodes_flow_node_unique"), table_name="flow_nodes")
    op.create_index(
        op.f("ix_flow_nodes_execution_context"),
        "flow_nodes",
        ["execution_context"],
        unique=False,
    )
    op.create_unique_constraint("uq_flow_node_id", "flow_nodes", ["flow_id", "node_id"])

    # Now create flow_connections FKs that reference the new flow_nodes unique constraint
    op.create_unique_constraint(
        "uq_flow_connection",
        "flow_connections",
        ["flow_id", "source_node_id", "target_node_id", "connection_type"],
    )
    op.create_foreign_key(
        "fk_connection_target_node",
        "flow_connections",
        "flow_nodes",
        ["flow_id", "target_node_id"],
        ["flow_id", "node_id"],
    )
    op.create_foreign_key(
        "fk_connection_source_node",
        "flow_connections",
        "flow_nodes",
        ["flow_id", "source_node_id"],
        ["flow_id", "node_id"],
    )
    op.drop_column("flow_connections", "updated_at")
    op.drop_index(op.f("idx_flow_definitions_theme_id"), table_name="flow_definitions")
    op.drop_constraint(
        op.f("fk_flow_definitions_theme_id"), "flow_definitions", type_="foreignkey"
    )
    op.drop_column("flow_definitions", "theme_id")
    op.drop_index(
        op.f("idx_exec_steps_session_step"), table_name="flow_execution_steps"
    )
    op.drop_index(op.f("idx_exec_steps_started"), table_name="flow_execution_steps")
    op.create_index(
        "ix_flowexecutionsteps_session_id_node_id",
        "flow_execution_steps",
        ["session_id", "node_id"],
        unique=False,
        postgresql_where=sa.text("error_message IS NOT NULL"),
    )
    op.create_index(
        "ix_flowexecutionsteps_session_id_started_at",
        "flow_execution_steps",
        ["session_id", "started_at"],
        unique=False,
        postgresql_where=sa.text("completed_at IS NOT NULL"),
    )
    op.create_index(
        "ix_flowexecutionsteps_session_id_step_number",
        "flow_execution_steps",
        ["session_id", "step_number"],
        unique=False,
    )
    op.drop_index(
        op.f("index_age_range"),
        table_name="labelsets",
        postgresql_where="((min_age IS NOT NULL) AND (max_age IS NOT NULL))",
    )
    op.drop_index(
        op.f("index_good_recommendations"),
        table_name="labelsets",
        postgresql_where="(recommend_status = 'GOOD'::recommendstatus)",
    )
    op.drop_index(op.f("index_work_labelsets"), table_name="labelsets")
    op.create_index(
        "ix_labelsets_min_age_max_age",
        "labelsets",
        ["min_age", "max_age"],
        unique=False,
        postgresql_where=sa.text("min_age IS NOT NULL AND max_age IS NOT NULL"),
    )
    op.create_index(
        "ix_labelsets_recommend_status",
        "labelsets",
        ["recommend_status"],
        unique=False,
        postgresql_where=sa.text("recommend_status = 'GOOD'"),
    )
    op.create_index(
        "ix_labelsets_work_id_id",
        "labelsets",
        ["work_id", sa.literal_column("id DESC")],
        unique=False,
    )
    op.drop_index(op.f("idx_schools_theme_id"), table_name="schools")
    op.drop_index(op.f("index_schools_by_country"), table_name="schools")
    op.drop_index(op.f("ix_school_state"), table_name="schools")
    op.create_index(
        "ix_schools_country_code_official_identifier",
        "schools",
        ["country_code", "official_identifier"],
        unique=True,
    )
    op.drop_constraint(op.f("fk_schools_theme_id"), "schools", type_="foreignkey")
    op.drop_column("schools", "theme_id")
    op.alter_column(
        "service_accounts", "is_active", existing_type=sa.BOOLEAN(), nullable=False
    )
    op.drop_constraint(
        op.f("unique_student_username_per_school"), "students", type_="unique"
    )
    op.create_unique_constraint(
        "uq_students_username_school_id", "students", ["username", "school_id"]
    )
    op.alter_column(
        "subscriptions", "is_active", existing_type=sa.BOOLEAN(), nullable=False
    )
    public_encode_uri_component = PGFunction(
        schema="public",
        signature="encode_uri_component(text)",
        definition="returns text\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\n    select string_agg(\n        case\n            when bytes > 1 or c !~ '[0-9a-zA-Z_.!~*''()-]+' then\n                regexp_replace(encode(convert_to(c, 'utf-8')::bytea, 'hex'), '(..)', E'%\\\\1', 'g')\n            else\n                c\n        end,\n        ''\n    )\n    from (\n        select c, octet_length(c) bytes\n        from regexp_split_to_table($1, '') c\n    ) q;\n$function$",
    )
    op.create_entity(public_encode_uri_component)

    public_notify_flow_event = PGFunction(
        schema="public",
        signature="notify_flow_event()",
        definition="returns trigger LANGUAGE plpgsql\n      AS $function$\n        BEGIN\n        -- Notify on session state changes with comprehensive event data\n        IF TG_OP = 'INSERT' THEN\n            PERFORM pg_notify(\n                'flow_events',\n                json_build_object(\n                    'event_type', 'session_started',\n                    'session_id', NEW.id,\n                    'flow_id', NEW.flow_id,\n                    'user_id', NEW.user_id,\n                    'current_node', NEW.current_node_id,\n                    'status', NEW.status,\n                    'revision', NEW.revision,\n                    'timestamp', extract(epoch from NEW.started_at)\n                )::text\n            );\n            RETURN NEW;\n        ELSIF TG_OP = 'UPDATE' THEN\n            -- Only notify on significant state changes (use IS DISTINCT FROM for NULL-safe comparison)\n            IF OLD.current_node_id IS DISTINCT FROM NEW.current_node_id\n               OR OLD.status IS DISTINCT FROM NEW.status\n               OR OLD.revision IS DISTINCT FROM NEW.revision THEN\n                PERFORM pg_notify(\n                    'flow_events',\n                    json_build_object(\n                        'event_type', CASE\n                            WHEN OLD.status IS DISTINCT FROM NEW.status THEN 'session_status_changed'\n                            WHEN OLD.current_node_id IS DISTINCT FROM NEW.current_node_id THEN 'node_changed'\n                            ELSE 'session_updated'\n                        END,\n                        'session_id', NEW.id,\n                        'flow_id', NEW.flow_id,\n                        'user_id', NEW.user_id,\n                        'current_node', NEW.current_node_id,\n                        'previous_node', OLD.current_node_id,\n                        'status', NEW.status,\n                        'previous_status', OLD.status,\n                        'revision', NEW.revision,\n                        'previous_revision', OLD.revision,\n                        'timestamp', extract(epoch from NEW.last_activity_at)\n                    )::text\n                );\n            END IF;\n            RETURN NEW;\n        ELSIF TG_OP = 'DELETE' THEN\n            PERFORM pg_notify(\n                'flow_events',\n                json_build_object(\n                    'event_type', 'session_deleted',\n                    'session_id', OLD.id,\n                    'flow_id', OLD.flow_id,\n                    'user_id', OLD.user_id,\n                    'timestamp', extract(epoch from NOW())\n                )::text\n            );\n            RETURN OLD;\n        END IF;\n        RETURN NULL;\n      END;\n      $function$",
    )
    op.replace_entity(public_notify_flow_event)

    public_fuzzystrmatch = PGExtension(schema="public", signature="fuzzystrmatch")
    op.drop_entity(public_fuzzystrmatch)

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    public_fuzzystrmatch = PGExtension(schema="public", signature="fuzzystrmatch")
    op.create_entity(public_fuzzystrmatch)

    public_notify_flow_event = PGFunction(
        schema="public",
        signature="notify_flow_event()",
        definition="returns trigger\n LANGUAGE plpgsql\nAS $function$\n        BEGIN\n            -- Notify on session state changes with comprehensive event data\n            IF TG_OP = 'INSERT' THEN\n                PERFORM pg_notify(\n                    'flow_events',\n                    json_build_object(\n                        'event_type', 'session_started',\n                        'session_id', NEW.id,\n                        'flow_id', NEW.flow_id,\n                        'user_id', NEW.user_id,\n                        'current_node', NEW.current_node_id,\n                        'status', NEW.status,\n                        'revision', NEW.revision,\n                        'timestamp', extract(epoch from NEW.started_at)\n                    )::text\n                );\n                RETURN NEW;\n            ELSIF TG_OP = 'UPDATE' THEN\n                -- Only notify on significant state changes\n                IF OLD.current_node_id IS DISTINCT FROM NEW.current_node_id \n                   OR OLD.status IS DISTINCT FROM NEW.status \n                   OR OLD.revision IS DISTINCT FROM NEW.revision THEN\n                    PERFORM pg_notify(\n                        'flow_events',\n                        json_build_object(\n                            'event_type', CASE \n                                WHEN OLD.status IS DISTINCT FROM NEW.status THEN 'session_status_changed'\n                                WHEN OLD.current_node_id IS DISTINCT FROM NEW.current_node_id THEN 'node_changed'\n                                ELSE 'session_updated'\n                            END,\n                            'session_id', NEW.id,\n                            'flow_id', NEW.flow_id,\n                            'user_id', NEW.user_id,\n                            'current_node', NEW.current_node_id,\n                            'previous_node', OLD.current_node_id,\n                            'status', NEW.status,\n                            'previous_status', OLD.status,\n                            'revision', NEW.revision,\n                            'previous_revision', OLD.revision,\n                            'timestamp', extract(epoch from NEW.last_activity_at)\n                        )::text\n                    );\n                END IF;\n                RETURN NEW;\n            ELSIF TG_OP = 'DELETE' THEN\n                PERFORM pg_notify(\n                    'flow_events',\n                    json_build_object(\n                        'event_type', 'session_deleted',\n                        'session_id', OLD.id,\n                        'flow_id', OLD.flow_id,\n                        'user_id', OLD.user_id,\n                        'timestamp', extract(epoch from NOW())\n                    )::text\n                );\n                RETURN OLD;\n            END IF;\n            RETURN NULL;\n        END;\n        $function$",
    )
    op.replace_entity(public_notify_flow_event)
    public_encode_uri_component = PGFunction(
        schema="public",
        signature="encode_uri_component(text)",
        definition="returns text\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\n    select string_agg(\n        case\n            when bytes > 1 or c !~ '[0-9a-zA-Z_.!~*''()-]+' then\n                regexp_replace(encode(convert_to(c, 'utf-8')::bytea, 'hex'), '(..)', E'%\\\\1', 'g')\n            else\n                c\n        end,\n        ''\n    )\n    from (\n        select c, octet_length(c) bytes\n        from regexp_split_to_table($1, '') c\n    ) q;\n$function$",
    )
    op.drop_entity(public_encode_uri_component)

    op.alter_column(
        "subscriptions", "is_active", existing_type=sa.BOOLEAN(), nullable=True
    )
    op.drop_constraint("uq_students_username_school_id", "students", type_="unique")
    op.create_unique_constraint(
        op.f("unique_student_username_per_school"),
        "students",
        ["username", "school_id"],
        postgresql_nulls_not_distinct=False,
    )
    op.alter_column(
        "service_accounts", "is_active", existing_type=sa.BOOLEAN(), nullable=True
    )
    op.add_column(
        "schools", sa.Column("theme_id", sa.UUID(), autoincrement=False, nullable=True)
    )
    op.create_foreign_key(
        op.f("fk_schools_theme_id"),
        "schools",
        "chat_themes",
        ["theme_id"],
        ["id"],
        ondelete="SET NULL",
    )
    op.drop_index("ix_schools_country_code_official_identifier", table_name="schools")
    op.create_index(
        op.f("ix_school_state"),
        "schools",
        [
            "country_code",
            sa.literal_column("((info -> 'location'::text) ->> 'state'::text)"),
        ],
        unique=False,
    )
    op.create_index(
        op.f("index_schools_by_country"),
        "schools",
        ["country_code", "official_identifier"],
        unique=True,
    )
    op.create_index(op.f("idx_schools_theme_id"), "schools", ["theme_id"], unique=False)
    op.drop_index("ix_labelsets_work_id_id", table_name="labelsets")
    op.drop_index(
        "ix_labelsets_recommend_status",
        table_name="labelsets",
        postgresql_where=sa.text("recommend_status = 'GOOD'"),
    )
    op.drop_index(
        "ix_labelsets_min_age_max_age",
        table_name="labelsets",
        postgresql_where=sa.text("min_age IS NOT NULL AND max_age IS NOT NULL"),
    )
    op.create_index(
        op.f("index_work_labelsets"),
        "labelsets",
        ["work_id", sa.literal_column("id DESC")],
        unique=False,
    )
    op.create_index(
        op.f("index_good_recommendations"),
        "labelsets",
        ["recommend_status"],
        unique=False,
        postgresql_where="(recommend_status = 'GOOD'::recommendstatus)",
    )
    op.create_index(
        op.f("index_age_range"),
        "labelsets",
        ["min_age", "max_age"],
        unique=False,
        postgresql_where="((min_age IS NOT NULL) AND (max_age IS NOT NULL))",
    )
    op.drop_constraint("uq_flow_node_id", "flow_nodes", type_="unique")
    op.drop_index(op.f("ix_flow_nodes_execution_context"), table_name="flow_nodes")
    op.create_index(
        op.f("ix_flow_nodes_flow_node_unique"),
        "flow_nodes",
        ["flow_id", "node_id"],
        unique=True,
    )
    op.create_index(
        op.f("ix_flow_nodes_flow_id"), "flow_nodes", ["flow_id"], unique=False
    )
    op.create_index(
        op.f("idx_flow_nodes_execution_context"),
        "flow_nodes",
        ["execution_context"],
        unique=False,
    )
    op.drop_index(
        "ix_flowexecutionsteps_session_id_step_number",
        table_name="flow_execution_steps",
    )
    op.drop_index(
        "ix_flowexecutionsteps_session_id_started_at",
        table_name="flow_execution_steps",
        postgresql_where=sa.text("completed_at IS NOT NULL"),
    )
    op.drop_index(
        "ix_flowexecutionsteps_session_id_node_id",
        table_name="flow_execution_steps",
        postgresql_where=sa.text("error_message IS NOT NULL"),
    )
    op.create_index(
        op.f("idx_exec_steps_started"),
        "flow_execution_steps",
        [sa.literal_column("started_at DESC")],
        unique=False,
    )
    op.create_index(
        op.f("idx_exec_steps_session_step"),
        "flow_execution_steps",
        ["session_id", "step_number"],
        unique=False,
    )
    op.add_column(
        "flow_definitions",
        sa.Column("theme_id", sa.UUID(), autoincrement=False, nullable=True),
    )
    op.create_foreign_key(
        op.f("fk_flow_definitions_theme_id"),
        "flow_definitions",
        "chat_themes",
        ["theme_id"],
        ["id"],
        ondelete="SET NULL",
    )
    op.create_index(
        op.f("idx_flow_definitions_theme_id"),
        "flow_definitions",
        ["theme_id"],
        unique=False,
    )
    op.add_column(
        "flow_connections",
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(),
            server_default=sa.text("CURRENT_TIMESTAMP"),
            autoincrement=False,
            nullable=False,
        ),
    )
    op.drop_constraint(
        "fk_connection_source_node", "flow_connections", type_="foreignkey"
    )
    op.drop_constraint(
        "fk_connection_target_node", "flow_connections", type_="foreignkey"
    )
    op.drop_constraint("uq_flow_connection", "flow_connections", type_="unique")
    op.drop_index(op.f("ix_event_outbox_routing_key"), table_name="event_outbox")
    op.drop_index(op.f("ix_event_outbox_correlation_id"), table_name="event_outbox")
    op.alter_column(
        "event_outbox",
        "error_details",
        existing_type=postgresql.JSONB(astext_type=sa.Text()),
        type_=postgresql.JSON(astext_type=sa.Text()),
        existing_nullable=True,
    )
    op.alter_column(
        "event_outbox",
        "headers",
        existing_type=postgresql.JSONB(astext_type=sa.Text()),
        type_=postgresql.JSON(astext_type=sa.Text()),
        existing_nullable=True,
    )
    op.alter_column(
        "event_outbox",
        "payload",
        existing_type=postgresql.JSONB(astext_type=sa.Text()),
        type_=postgresql.JSON(astext_type=sa.Text()),
        existing_nullable=False,
    )
    op.add_column(
        "conversation_analytics",
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(),
            server_default=sa.text("CURRENT_TIMESTAMP"),
            autoincrement=False,
            nullable=False,
        ),
    )
    op.drop_constraint(
        "uq_analytics_flow_node_date", "conversation_analytics", type_="unique"
    )
    op.create_index(
        op.f("ix_conversation_analytics_flow_id"),
        "conversation_analytics",
        ["flow_id"],
        unique=False,
    )
    op.drop_constraint(
        "uq_collection_items_collection_id_edition_isbn",
        "collection_items",
        type_="unique",
    )
    op.create_unique_constraint(
        op.f("unique_editions_per_collection"),
        "collection_items",
        ["collection_id", "edition_isbn"],
        postgresql_nulls_not_distinct=False,
    )
    op.drop_index(
        "ix_collectionitemactivitys_timestamp_reader_id",
        table_name="collection_item_activity_log",
    )
    op.create_index(
        op.f("idx_collection_item_activity_log_timestamp_reader_id"),
        "collection_item_activity_log",
        ["timestamp", "reader_id"],
        unique=False,
    )
    op.add_column(
        "cms_content_variants",
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(),
            server_default=sa.text("CURRENT_TIMESTAMP"),
            autoincrement=False,
            nullable=False,
        ),
    )
    op.drop_constraint("uq_content_variant_key", "cms_content_variants", type_="unique")
    op.create_index(
        op.f("ix_cms_content_variants_is_active"),
        "cms_content_variants",
        ["is_active"],
        unique=False,
    )
    op.create_index(
        op.f("ix_cms_content_variants_content_id"),
        "cms_content_variants",
        ["content_id"],
        unique=False,
    )
    op.alter_column(
        "cms_content_variants",
        "performance_data",
        existing_type=sa.JSON(),
        type_=postgresql.JSONB(astext_type=sa.Text()),
        existing_nullable=False,
        existing_server_default=sa.text("'{}'::json"),
    )
    op.drop_index(
        "ix_cms_content_search_document",
        table_name="cms_content",
        postgresql_using="gin",
    )
    op.create_index(
        op.f("idx_cms_content_search_document"),
        "cms_content",
        ["search_document"],
        unique=False,
        postgresql_using="gin",
    )
    op.drop_constraint("uq_class_groups_name_school_id", "class_groups", type_="unique")
    op.create_unique_constraint(
        op.f("unique_class_name_per_school"),
        "class_groups",
        ["name", "school_id"],
        postgresql_nulls_not_distinct=False,
    )
    op.drop_index(op.f("ix_chat_themes_school_id"), table_name="chat_themes")
    op.drop_index(op.f("ix_chat_themes_is_active"), table_name="chat_themes")
    op.create_index(
        op.f("idx_chat_themes_school_id"), "chat_themes", ["school_id"], unique=False
    )
    op.create_index(
        op.f("idx_chat_themes_is_default"), "chat_themes", ["is_default"], unique=False
    )
    op.create_index(
        op.f("idx_chat_themes_is_active"), "chat_themes", ["is_active"], unique=False
    )
    op.create_index(
        op.f("idx_chat_themes_created_by"), "chat_themes", ["created_by"], unique=False
    )
    op.drop_constraint(
        "uq_booklistworkassociations_booklist_id_order_id",
        "book_list_works",
        type_="unique",
    )
    op.drop_index(
        "ix_booklistworkassociations_booklist_id_order_id", table_name="book_list_works"
    )
    op.create_index(
        op.f("index_booklist_ordered"),
        "book_list_works",
        ["booklist_id", "order_id"],
        unique=False,
    )
    op.create_unique_constraint(
        op.f("ck_booklist_order"),
        "book_list_works",
        ["booklist_id", "order_id"],
        postgresql_nulls_not_distinct=False,
    )
    # ### end Alembic commands ###
