"""Create chatbot triggers

Revision ID: e2a71c5767b1
Revises: 2e8dc6b4f10c
Create Date: 2025-06-15 22:26:27.946492

"""

import sqlalchemy as sa
from alembic_utils.pg_extension import PGExtension
from alembic_utils.pg_function import PGFunction
from alembic_utils.pg_trigger import PGTrigger
from sqlalchemy import text as sql_text
from sqlalchemy.dialects import postgresql

from alembic import op

# revision identifiers, used by Alembic.
revision = "e2a71c5767b1"
down_revision = "2e8dc6b4f10c"
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    public_notify_flow_event = PGFunction(
        schema="public",
        signature="notify_flow_event()",
        definition="returns trigger LANGUAGE plpgsql\n      AS $function$\n        BEGIN\n        -- Notify on session state changes with comprehensive event data\n        IF TG_OP = 'INSERT' THEN\n            PERFORM pg_notify(\n                'flow_events',\n                json_build_object(\n                    'event_type', 'session_started',\n                    'session_id', NEW.id,\n                    'flow_id', NEW.flow_id,\n                    'user_id', NEW.user_id,\n                    'current_node', NEW.current_node_id,\n                    'status', NEW.status,\n                    'revision', NEW.revision,\n                    'timestamp', extract(epoch from NEW.created_at)\n                )::text\n            );\n            RETURN NEW;\n        ELSIF TG_OP = 'UPDATE' THEN\n            -- Only notify on significant state changes\n            IF OLD.current_node_id != NEW.current_node_id \n               OR OLD.status != NEW.status \n               OR OLD.revision != NEW.revision THEN\n                PERFORM pg_notify(\n                    'flow_events',\n                    json_build_object(\n                        'event_type', CASE \n                            WHEN OLD.status != NEW.status THEN 'session_status_changed'\n                            WHEN OLD.current_node_id != NEW.current_node_id THEN 'node_changed'\n                            ELSE 'session_updated'\n                        END,\n                        'session_id', NEW.id,\n                        'flow_id', NEW.flow_id,\n                        'user_id', NEW.user_id,\n                        'current_node', NEW.current_node_id,\n                        'previous_node', OLD.current_node_id,\n                        'status', NEW.status,\n                        'previous_status', OLD.status,\n                        'revision', NEW.revision,\n                        'previous_revision', OLD.revision,\n                        'timestamp', extract(epoch from NEW.updated_at)\n                    )::text\n                );\n            END IF;\n            RETURN NEW;\n        ELSIF TG_OP = 'DELETE' THEN\n            PERFORM pg_notify(\n                'flow_events',\n                json_build_object(\n                    'event_type', 'session_deleted',\n                    'session_id', OLD.id,\n                    'flow_id', OLD.flow_id,\n                    'user_id', OLD.user_id,\n                    'timestamp', extract(epoch from NOW())\n                )::text\n            );\n            RETURN OLD;\n        END IF;\n        RETURN NULL;\n      END;\n      $function$",
    )
    op.create_entity(public_notify_flow_event)

    public_conversation_sessions_conversation_sessions_notify_flow_event_trigger = PGTrigger(
        schema="public",
        signature="conversation_sessions_notify_flow_event_trigger",
        on_entity="public.conversation_sessions",
        is_constraint=False,
        definition="AFTER INSERT OR UPDATE OR DELETE ON public.conversation_sessions \n                  FOR EACH ROW EXECUTE FUNCTION notify_flow_event()",
    )
    op.create_entity(
        public_conversation_sessions_conversation_sessions_notify_flow_event_trigger
    )

    public_collection_items_update_collections_trigger = PGTrigger(
        schema="public",
        signature="update_collections_trigger",
        on_entity="public.collection_items",
        is_constraint=False,
        definition="AFTER INSERT OR UPDATE ON public.collection_items FOR EACH ROW EXECUTE FUNCTION update_collections_function()",
    )
    op.drop_entity(public_collection_items_update_collections_trigger)

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###

    public_collection_items_update_collections_trigger = PGTrigger(
        schema="public",
        signature="update_collections_trigger",
        on_entity="public.collection_items",
        is_constraint=False,
        definition="AFTER INSERT OR UPDATE ON public.collection_items FOR EACH ROW EXECUTE FUNCTION update_collections_function()",
    )
    op.create_entity(public_collection_items_update_collections_trigger)

    public_conversation_sessions_conversation_sessions_notify_flow_event_trigger = PGTrigger(
        schema="public",
        signature="conversation_sessions_notify_flow_event_trigger",
        on_entity="public.conversation_sessions",
        is_constraint=False,
        definition="AFTER INSERT OR UPDATE OR DELETE ON public.conversation_sessions \n                  FOR EACH ROW EXECUTE FUNCTION notify_flow_event()",
    )
    op.drop_entity(
        public_conversation_sessions_conversation_sessions_notify_flow_event_trigger
    )

    public_notify_flow_event = PGFunction(
        schema="public",
        signature="notify_flow_event()",
        definition="returns trigger LANGUAGE plpgsql\n      AS $function$\n        BEGIN\n        -- Notify on session state changes with comprehensive event data\n        IF TG_OP = 'INSERT' THEN\n            PERFORM pg_notify(\n                'flow_events',\n                json_build_object(\n                    'event_type', 'session_started',\n                    'session_id', NEW.id,\n                    'flow_id', NEW.flow_id,\n                    'user_id', NEW.user_id,\n                    'current_node', NEW.current_node_id,\n                    'status', NEW.status,\n                    'revision', NEW.revision,\n                    'timestamp', extract(epoch from NEW.created_at)\n                )::text\n            );\n            RETURN NEW;\n        ELSIF TG_OP = 'UPDATE' THEN\n            -- Only notify on significant state changes\n            IF OLD.current_node_id != NEW.current_node_id \n               OR OLD.status != NEW.status \n               OR OLD.revision != NEW.revision THEN\n                PERFORM pg_notify(\n                    'flow_events',\n                    json_build_object(\n                        'event_type', CASE \n                            WHEN OLD.status != NEW.status THEN 'session_status_changed'\n                            WHEN OLD.current_node_id != NEW.current_node_id THEN 'node_changed'\n                            ELSE 'session_updated'\n                        END,\n                        'session_id', NEW.id,\n                        'flow_id', NEW.flow_id,\n                        'user_id', NEW.user_id,\n                        'current_node', NEW.current_node_id,\n                        'previous_node', OLD.current_node_id,\n                        'status', NEW.status,\n                        'previous_status', OLD.status,\n                        'revision', NEW.revision,\n                        'previous_revision', OLD.revision,\n                        'timestamp', extract(epoch from NEW.updated_at)\n                    )::text\n                );\n            END IF;\n            RETURN NEW;\n        ELSIF TG_OP = 'DELETE' THEN\n            PERFORM pg_notify(\n                'flow_events',\n                json_build_object(\n                    'event_type', 'session_deleted',\n                    'session_id', OLD.id,\n                    'flow_id', OLD.flow_id,\n                    'user_id', OLD.user_id,\n                    'timestamp', extract(epoch from NOW())\n                )::text\n            );\n            RETURN OLD;\n        END IF;\n        RETURN NULL;\n      END;\n      $function$",
    )
    op.drop_entity(public_notify_flow_event)

    # ### end Alembic commands ###
