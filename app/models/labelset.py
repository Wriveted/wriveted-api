from datetime import datetime
from typing import TYPE_CHECKING, Any, Dict, List, Optional

from sqlalchemy import (
    Boolean,
    DateTime,
    Enum,
    ForeignKey,
    Index,
    Integer,
    Text,
    and_,
    func,
)
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.ext.mutable import MutableDict
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.db import Base
from app.models.hue import Hue
from app.models.labelset_hue_association import LabelSetHue, Ordinal
from app.models.labelset_reading_ability_association import LabelSetReadingAbility
from app.schemas import CaseInsensitiveStringEnum

if TYPE_CHECKING:
    from app.models.reading_ability import ReadingAbility
    from app.models.work import Work


class RecommendStatus(CaseInsensitiveStringEnum):
    GOOD = "GOOD"  # Good to Recommend
    BAD_BORING = "BAD_BORING"  # Too boring
    BAD_REFERENCE = "BAD_REFERENCE"  # Reference/Education book
    BAD_CONTROVERSIAL = "BAD_CONTROVERSIAL"  # Controversial content
    BAD_LOW_QUALITY = "BAD_LOW_QUALITY"  # Not a great example


class LabelOrigin(CaseInsensitiveStringEnum):
    HUMAN = "HUMAN"  # Human-provided
    GPT4 = "GPT4"  # Generated by GPT-4
    VERTEXAI = "VERTEXAI"  # Generated by VertexAI
    PREDICTED_NIELSEN = "PREDICTED_NIELSEN"  # Predicted based on metadata from Nielsen
    NIELSEN_CBMC = "NIELSEN_CBMC"
    NIELSEN_BIC = "NIELSEN_BIC"
    NIELSEN_THEMA = "NIELSEN_THEMA"
    NIELSEN_IA = "NIELSEN_IA"
    NIELSEN_RA = "NIELSEN_RA"
    CLUSTER_RELEVANCE = "CLUSTER_RELEVANCE"  # Relevance AI cluster
    CLUSTER_ZAINAB = "CLUSTER_ZAINAB"  # Original K-Means clustering by Zainab
    OTHER = "OTHER"


# an abstraction of the "label" related properties of a Work, which are likely to be human-provided.
# this is what Huey will look at when making recommendations, and the fields can sometimes be computed
# by combining data from editions' metdata.
class LabelSet(Base):
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)

    work_id: Mapped[Optional[int]] = mapped_column(
        ForeignKey("works.id", name="fk_labelset_work"), nullable=True, index=True
    )
    work: Mapped[Optional["Work"]] = relationship("Work", back_populates="labelset")

    # Create an index used to find the most recent labelsets for a work
    Index(
        "ix_labelsets_work_id_id",
        work_id,
        id.desc(),
    )

    # Handle Multiple Hues via a secondary association table,
    # discerned via an 'ordinal' (primary/secondary/tertiary)
    hues: Mapped[List["Hue"]] = relationship(
        "Hue",
        secondary=LabelSetHue.__table__,
        lazy="selectin",
    )

    hue_origin: Mapped[Optional[LabelOrigin]] = mapped_column(
        Enum(LabelOrigin), nullable=True
    )

    huey_summary: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    summary_origin: Mapped[Optional[LabelOrigin]] = mapped_column(
        Enum(LabelOrigin), nullable=True
    )

    reading_abilities: Mapped[List["ReadingAbility"]] = relationship(
        "ReadingAbility",
        secondary=LabelSetReadingAbility.__table__,
        back_populates="labelsets",
        lazy="selectin",
    )
    reading_ability_origin: Mapped[Optional[LabelOrigin]] = mapped_column(
        Enum(LabelOrigin), nullable=True
    )

    min_age: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    max_age: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    Index(
        "ix_labelsets_min_age_max_age",
        min_age,
        max_age,
        postgresql_where=and_(min_age.is_not(None), max_age.is_not(None)),
    )

    age_origin: Mapped[Optional[LabelOrigin]] = mapped_column(
        Enum(LabelOrigin), nullable=True
    )

    recommend_status: Mapped[RecommendStatus] = mapped_column(
        Enum(RecommendStatus), nullable=False, server_default="GOOD"
    )
    Index(
        "ix_labelsets_recommend_status",
        recommend_status,
        postgresql_where=(recommend_status == RecommendStatus.GOOD),
    )

    recommend_status_origin: Mapped[Optional[LabelOrigin]] = mapped_column(
        Enum(LabelOrigin), nullable=True
    )

    # both service accounts and users could potentially label works
    labelled_by_user_id: Mapped[Optional[int]] = mapped_column(
        ForeignKey("users.id", name="fk_labeller-user_labelset"), nullable=True
    )
    labelled_by_sa_id: Mapped[Optional[int]] = mapped_column(
        ForeignKey("service_accounts.id", name="fk_labeller-sa_labelset"), nullable=True
    )

    info: Mapped[Optional[dict]] = mapped_column(MutableDict.as_mutable(JSONB))  # type: ignore[arg-type]

    created_at: Mapped[datetime] = mapped_column(
        DateTime,
        server_default=func.current_timestamp(),
        default=datetime.utcnow,
        nullable=False,
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime,
        server_default=func.current_timestamp(),
        default=datetime.utcnow,
        onupdate=datetime.utcnow,
        nullable=False,
    )

    checked: Mapped[Optional[bool]] = mapped_column(Boolean(), nullable=True)
    checked_at: Mapped[Optional[datetime]] = mapped_column(DateTime, nullable=True)

    # Partial covering indexes for labeller foreign relations
    __table_args__ = (
        Index(
            "ix_labelset_user_id",
            "labelled_by_user_id",
            postgresql_where=labelled_by_user_id.is_not(None),
        ),
        Index(
            "ix_labelset_service_account_id",
            "labelled_by_sa_id",
            postgresql_where=labelled_by_sa_id.is_not(None),
        ),
    )

    def __repr__(self) -> str:
        work_title = self.work.title if self.work else "No Work"
        return f"<LabelSet id={self.id} - '{work_title}' ages: {self.min_age}-{self.max_age} >"

    def __str__(self) -> str:
        hues = [h.name for h in self.hues]
        reading_abilities = [ra.key for ra in self.reading_abilities]
        work_title = self.work.title if self.work else "No Work"
        return f"'{work_title}' reading ability: {reading_abilities} ages: {self.min_age}-{self.max_age} Hues: {hues}"

    def get_label_dict(self, session: Any) -> Dict[str, Any]:
        label_dict = {}

        for hue, ordinal in (
            session.query(Hue, LabelSetHue.ordinal)
            .join(LabelSetHue)
            .filter(LabelSetHue.labelset_id == self.id)
            .all()
        ):
            if ordinal == Ordinal.PRIMARY:
                label_dict["primary_hue_key"] = hue.key
            elif ordinal == Ordinal.SECONDARY:
                label_dict["secondary_hue_key"] = hue.key
            elif ordinal == Ordinal.TERTIARY:
                label_dict["tertiary_hue_key"] = hue.key
        label_dict["hue_origin"] = self.hue_origin.value if self.hue_origin else None

        label_dict["reading_ability_keys"] = [ra.key for ra in self.reading_abilities]
        label_dict["reading_ability_origin"] = (
            self.reading_ability_origin.value if self.reading_ability_origin else None
        )

        label_dict["min_age"] = self.min_age
        label_dict["max_age"] = self.max_age
        label_dict["age_origin"] = self.age_origin.value if self.age_origin else None

        label_dict["recommend_status"] = self.recommend_status.value
        label_dict["recommend_status_origin"] = (
            self.recommend_status_origin.value if self.recommend_status_origin else None
        )

        label_dict["huey_summary"] = self.huey_summary
        label_dict["summary_origin"] = (
            self.summary_origin.value if self.summary_origin else None
        )

        label_dict["labelled_by_user_id"] = (
            str(self.labelled_by_user_id) if self.labelled_by_user_id else None
        )
        label_dict["labelled_by_sa_id"] = (
            str(self.labelled_by_sa_id) if self.labelled_by_sa_id else None
        )

        label_dict["checked"] = self.checked
        label_dict["checked_at"] = str(self.checked_at)

        label_dict["created_at"] = str(self.created_at)
        label_dict["updated_at"] = str(self.updated_at)

        label_dict["info"] = self.info

        return label_dict
